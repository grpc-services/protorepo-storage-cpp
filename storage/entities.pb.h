// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: storage/entities.proto

#ifndef PROTOBUF_storage_2fentities_2eproto__INCLUDED
#define PROTOBUF_storage_2fentities_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common/Timestamp.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_storage_2fentities_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsHashesImpl();
void InitDefaultsHashes();
void InitDefaultsFolderFacetImpl();
void InitDefaultsFolderFacet();
void InitDefaultsFileFacetImpl();
void InitDefaultsFileFacet();
void InitDefaultsAudioFacetImpl();
void InitDefaultsAudioFacet();
void InitDefaultsDriveImpl();
void InitDefaultsDrive();
void InitDefaultsItemImpl();
void InitDefaultsItem();
inline void InitDefaults() {
  InitDefaultsHashes();
  InitDefaultsFolderFacet();
  InitDefaultsFileFacet();
  InitDefaultsAudioFacet();
  InitDefaultsDrive();
  InitDefaultsItem();
}
}  // namespace protobuf_storage_2fentities_2eproto
namespace grpc_services {
namespace storage {
class AudioFacet;
class AudioFacetDefaultTypeInternal;
extern AudioFacetDefaultTypeInternal _AudioFacet_default_instance_;
class Drive;
class DriveDefaultTypeInternal;
extern DriveDefaultTypeInternal _Drive_default_instance_;
class FileFacet;
class FileFacetDefaultTypeInternal;
extern FileFacetDefaultTypeInternal _FileFacet_default_instance_;
class FolderFacet;
class FolderFacetDefaultTypeInternal;
extern FolderFacetDefaultTypeInternal _FolderFacet_default_instance_;
class Hashes;
class HashesDefaultTypeInternal;
extern HashesDefaultTypeInternal _Hashes_default_instance_;
class Item;
class ItemDefaultTypeInternal;
extern ItemDefaultTypeInternal _Item_default_instance_;
}  // namespace storage
}  // namespace grpc_services
namespace grpc_services {
namespace storage {

// ===================================================================

class Hashes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc_services.storage.Hashes) */ {
 public:
  Hashes();
  virtual ~Hashes();

  Hashes(const Hashes& from);

  inline Hashes& operator=(const Hashes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Hashes(Hashes&& from) noexcept
    : Hashes() {
    *this = ::std::move(from);
  }

  inline Hashes& operator=(Hashes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Hashes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Hashes* internal_default_instance() {
    return reinterpret_cast<const Hashes*>(
               &_Hashes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Hashes* other);
  friend void swap(Hashes& a, Hashes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Hashes* New() const PROTOBUF_FINAL { return New(NULL); }

  Hashes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Hashes& from);
  void MergeFrom(const Hashes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Hashes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string crc32 = 1;
  void clear_crc32();
  static const int kCrc32FieldNumber = 1;
  const ::std::string& crc32() const;
  void set_crc32(const ::std::string& value);
  #if LANG_CXX11
  void set_crc32(::std::string&& value);
  #endif
  void set_crc32(const char* value);
  void set_crc32(const char* value, size_t size);
  ::std::string* mutable_crc32();
  ::std::string* release_crc32();
  void set_allocated_crc32(::std::string* crc32);

  // string sha1 = 2;
  void clear_sha1();
  static const int kSha1FieldNumber = 2;
  const ::std::string& sha1() const;
  void set_sha1(const ::std::string& value);
  #if LANG_CXX11
  void set_sha1(::std::string&& value);
  #endif
  void set_sha1(const char* value);
  void set_sha1(const char* value, size_t size);
  ::std::string* mutable_sha1();
  ::std::string* release_sha1();
  void set_allocated_sha1(::std::string* sha1);

  // string md5 = 3;
  void clear_md5();
  static const int kMd5FieldNumber = 3;
  const ::std::string& md5() const;
  void set_md5(const ::std::string& value);
  #if LANG_CXX11
  void set_md5(::std::string&& value);
  #endif
  void set_md5(const char* value);
  void set_md5(const char* value, size_t size);
  ::std::string* mutable_md5();
  ::std::string* release_md5();
  void set_allocated_md5(::std::string* md5);

  // string sha512 = 4;
  void clear_sha512();
  static const int kSha512FieldNumber = 4;
  const ::std::string& sha512() const;
  void set_sha512(const ::std::string& value);
  #if LANG_CXX11
  void set_sha512(::std::string&& value);
  #endif
  void set_sha512(const char* value);
  void set_sha512(const char* value, size_t size);
  ::std::string* mutable_sha512();
  ::std::string* release_sha512();
  void set_allocated_sha512(::std::string* sha512);

  // @@protoc_insertion_point(class_scope:grpc_services.storage.Hashes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr crc32_;
  ::google::protobuf::internal::ArenaStringPtr sha1_;
  ::google::protobuf::internal::ArenaStringPtr md5_;
  ::google::protobuf::internal::ArenaStringPtr sha512_;
  mutable int _cached_size_;
  friend struct ::protobuf_storage_2fentities_2eproto::TableStruct;
  friend void ::protobuf_storage_2fentities_2eproto::InitDefaultsHashesImpl();
};
// -------------------------------------------------------------------

class FolderFacet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc_services.storage.FolderFacet) */ {
 public:
  FolderFacet();
  virtual ~FolderFacet();

  FolderFacet(const FolderFacet& from);

  inline FolderFacet& operator=(const FolderFacet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FolderFacet(FolderFacet&& from) noexcept
    : FolderFacet() {
    *this = ::std::move(from);
  }

  inline FolderFacet& operator=(FolderFacet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FolderFacet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FolderFacet* internal_default_instance() {
    return reinterpret_cast<const FolderFacet*>(
               &_FolderFacet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(FolderFacet* other);
  friend void swap(FolderFacet& a, FolderFacet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FolderFacet* New() const PROTOBUF_FINAL { return New(NULL); }

  FolderFacet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FolderFacet& from);
  void MergeFrom(const FolderFacet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FolderFacet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 num_items = 1;
  void clear_num_items();
  static const int kNumItemsFieldNumber = 1;
  ::google::protobuf::uint64 num_items() const;
  void set_num_items(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:grpc_services.storage.FolderFacet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 num_items_;
  mutable int _cached_size_;
  friend struct ::protobuf_storage_2fentities_2eproto::TableStruct;
  friend void ::protobuf_storage_2fentities_2eproto::InitDefaultsFolderFacetImpl();
};
// -------------------------------------------------------------------

class FileFacet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc_services.storage.FileFacet) */ {
 public:
  FileFacet();
  virtual ~FileFacet();

  FileFacet(const FileFacet& from);

  inline FileFacet& operator=(const FileFacet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileFacet(FileFacet&& from) noexcept
    : FileFacet() {
    *this = ::std::move(from);
  }

  inline FileFacet& operator=(FileFacet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FileFacet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileFacet* internal_default_instance() {
    return reinterpret_cast<const FileFacet*>(
               &_FileFacet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(FileFacet* other);
  friend void swap(FileFacet& a, FileFacet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileFacet* New() const PROTOBUF_FINAL { return New(NULL); }

  FileFacet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FileFacet& from);
  void MergeFrom(const FileFacet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FileFacet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string mime_type = 2;
  void clear_mime_type();
  static const int kMimeTypeFieldNumber = 2;
  const ::std::string& mime_type() const;
  void set_mime_type(const ::std::string& value);
  #if LANG_CXX11
  void set_mime_type(::std::string&& value);
  #endif
  void set_mime_type(const char* value);
  void set_mime_type(const char* value, size_t size);
  ::std::string* mutable_mime_type();
  ::std::string* release_mime_type();
  void set_allocated_mime_type(::std::string* mime_type);

  // .grpc_services.storage.Hashes hashes = 1;
  bool has_hashes() const;
  void clear_hashes();
  static const int kHashesFieldNumber = 1;
  const ::grpc_services::storage::Hashes& hashes() const;
  ::grpc_services::storage::Hashes* release_hashes();
  ::grpc_services::storage::Hashes* mutable_hashes();
  void set_allocated_hashes(::grpc_services::storage::Hashes* hashes);

  // .grpc_services.storage.AudioFacet audio = 3;
  bool has_audio() const;
  void clear_audio();
  static const int kAudioFieldNumber = 3;
  const ::grpc_services::storage::AudioFacet& audio() const;
  ::grpc_services::storage::AudioFacet* release_audio();
  ::grpc_services::storage::AudioFacet* mutable_audio();
  void set_allocated_audio(::grpc_services::storage::AudioFacet* audio);

  // @@protoc_insertion_point(class_scope:grpc_services.storage.FileFacet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr mime_type_;
  ::grpc_services::storage::Hashes* hashes_;
  ::grpc_services::storage::AudioFacet* audio_;
  mutable int _cached_size_;
  friend struct ::protobuf_storage_2fentities_2eproto::TableStruct;
  friend void ::protobuf_storage_2fentities_2eproto::InitDefaultsFileFacetImpl();
};
// -------------------------------------------------------------------

class AudioFacet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc_services.storage.AudioFacet) */ {
 public:
  AudioFacet();
  virtual ~AudioFacet();

  AudioFacet(const AudioFacet& from);

  inline AudioFacet& operator=(const AudioFacet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AudioFacet(AudioFacet&& from) noexcept
    : AudioFacet() {
    *this = ::std::move(from);
  }

  inline AudioFacet& operator=(AudioFacet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioFacet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AudioFacet* internal_default_instance() {
    return reinterpret_cast<const AudioFacet*>(
               &_AudioFacet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(AudioFacet* other);
  friend void swap(AudioFacet& a, AudioFacet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AudioFacet* New() const PROTOBUF_FINAL { return New(NULL); }

  AudioFacet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AudioFacet& from);
  void MergeFrom(const AudioFacet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AudioFacet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 bitrate = 1;
  void clear_bitrate();
  static const int kBitrateFieldNumber = 1;
  ::google::protobuf::uint64 bitrate() const;
  void set_bitrate(::google::protobuf::uint64 value);

  // uint64 duration = 2;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  ::google::protobuf::uint64 duration() const;
  void set_duration(::google::protobuf::uint64 value);

  // bool is_vbr = 3;
  void clear_is_vbr();
  static const int kIsVbrFieldNumber = 3;
  bool is_vbr() const;
  void set_is_vbr(bool value);

  // @@protoc_insertion_point(class_scope:grpc_services.storage.AudioFacet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 bitrate_;
  ::google::protobuf::uint64 duration_;
  bool is_vbr_;
  mutable int _cached_size_;
  friend struct ::protobuf_storage_2fentities_2eproto::TableStruct;
  friend void ::protobuf_storage_2fentities_2eproto::InitDefaultsAudioFacetImpl();
};
// -------------------------------------------------------------------

class Drive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc_services.storage.Drive) */ {
 public:
  Drive();
  virtual ~Drive();

  Drive(const Drive& from);

  inline Drive& operator=(const Drive& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Drive(Drive&& from) noexcept
    : Drive() {
    *this = ::std::move(from);
  }

  inline Drive& operator=(Drive&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Drive& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Drive* internal_default_instance() {
    return reinterpret_cast<const Drive*>(
               &_Drive_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Drive* other);
  friend void swap(Drive& a, Drive& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Drive* New() const PROTOBUF_FINAL { return New(NULL); }

  Drive* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Drive& from);
  void MergeFrom(const Drive& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Drive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // .grpc_services.common.Timestamp created_time = 4;
  bool has_created_time() const;
  void clear_created_time();
  static const int kCreatedTimeFieldNumber = 4;
  const ::grpc_services::common::Timestamp& created_time() const;
  ::grpc_services::common::Timestamp* release_created_time();
  ::grpc_services::common::Timestamp* mutable_created_time();
  void set_allocated_created_time(::grpc_services::common::Timestamp* created_time);

  // .grpc_services.common.Timestamp last_modified = 5;
  bool has_last_modified() const;
  void clear_last_modified();
  static const int kLastModifiedFieldNumber = 5;
  const ::grpc_services::common::Timestamp& last_modified() const;
  ::grpc_services::common::Timestamp* release_last_modified();
  ::grpc_services::common::Timestamp* mutable_last_modified();
  void set_allocated_last_modified(::grpc_services::common::Timestamp* last_modified);

  // .grpc_services.common.Timestamp last_item_modified = 6;
  bool has_last_item_modified() const;
  void clear_last_item_modified();
  static const int kLastItemModifiedFieldNumber = 6;
  const ::grpc_services::common::Timestamp& last_item_modified() const;
  ::grpc_services::common::Timestamp* release_last_item_modified();
  ::grpc_services::common::Timestamp* mutable_last_item_modified();
  void set_allocated_last_item_modified(::grpc_services::common::Timestamp* last_item_modified);

  // @@protoc_insertion_point(class_scope:grpc_services.storage.Drive)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::grpc_services::common::Timestamp* created_time_;
  ::grpc_services::common::Timestamp* last_modified_;
  ::grpc_services::common::Timestamp* last_item_modified_;
  mutable int _cached_size_;
  friend struct ::protobuf_storage_2fentities_2eproto::TableStruct;
  friend void ::protobuf_storage_2fentities_2eproto::InitDefaultsDriveImpl();
};
// -------------------------------------------------------------------

class Item : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:grpc_services.storage.Item) */ {
 public:
  Item();
  virtual ~Item();

  Item(const Item& from);

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Item(Item&& from) noexcept
    : Item() {
    *this = ::std::move(from);
  }

  inline Item& operator=(Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Item& default_instance();

  enum TestTypeCase {
    kFile = 8,
    kFolder = 9,
    TEST_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Item* internal_default_instance() {
    return reinterpret_cast<const Item*>(
               &_Item_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Item* other);
  friend void swap(Item& a, Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Item* New() const PROTOBUF_FINAL { return New(NULL); }

  Item* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Item& from);
  void MergeFrom(const Item& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Item* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string parent_id = 6;
  void clear_parent_id();
  static const int kParentIdFieldNumber = 6;
  const ::std::string& parent_id() const;
  void set_parent_id(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_id(::std::string&& value);
  #endif
  void set_parent_id(const char* value);
  void set_parent_id(const char* value, size_t size);
  ::std::string* mutable_parent_id();
  ::std::string* release_parent_id();
  void set_allocated_parent_id(::std::string* parent_id);

  // .grpc_services.common.Timestamp created_time = 4;
  bool has_created_time() const;
  void clear_created_time();
  static const int kCreatedTimeFieldNumber = 4;
  const ::grpc_services::common::Timestamp& created_time() const;
  ::grpc_services::common::Timestamp* release_created_time();
  ::grpc_services::common::Timestamp* mutable_created_time();
  void set_allocated_created_time(::grpc_services::common::Timestamp* created_time);

  // .grpc_services.common.Timestamp last_modified = 5;
  bool has_last_modified() const;
  void clear_last_modified();
  static const int kLastModifiedFieldNumber = 5;
  const ::grpc_services::common::Timestamp& last_modified() const;
  ::grpc_services::common::Timestamp* release_last_modified();
  ::grpc_services::common::Timestamp* mutable_last_modified();
  void set_allocated_last_modified(::grpc_services::common::Timestamp* last_modified);

  // uint64 size = 7;
  void clear_size();
  static const int kSizeFieldNumber = 7;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // .grpc_services.storage.FileFacet file = 8;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 8;
  const ::grpc_services::storage::FileFacet& file() const;
  ::grpc_services::storage::FileFacet* release_file();
  ::grpc_services::storage::FileFacet* mutable_file();
  void set_allocated_file(::grpc_services::storage::FileFacet* file);

  // .grpc_services.storage.FolderFacet folder = 9;
  bool has_folder() const;
  void clear_folder();
  static const int kFolderFieldNumber = 9;
  const ::grpc_services::storage::FolderFacet& folder() const;
  ::grpc_services::storage::FolderFacet* release_folder();
  ::grpc_services::storage::FolderFacet* mutable_folder();
  void set_allocated_folder(::grpc_services::storage::FolderFacet* folder);

  TestTypeCase test_type_case() const;
  // @@protoc_insertion_point(class_scope:grpc_services.storage.Item)
 private:
  void set_has_file();
  void set_has_folder();

  inline bool has_test_type() const;
  void clear_test_type();
  inline void clear_has_test_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr parent_id_;
  ::grpc_services::common::Timestamp* created_time_;
  ::grpc_services::common::Timestamp* last_modified_;
  ::google::protobuf::uint64 size_;
  union TestTypeUnion {
    TestTypeUnion() {}
    ::grpc_services::storage::FileFacet* file_;
    ::grpc_services::storage::FolderFacet* folder_;
  } test_type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_storage_2fentities_2eproto::TableStruct;
  friend void ::protobuf_storage_2fentities_2eproto::InitDefaultsItemImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Hashes

// string crc32 = 1;
inline void Hashes::clear_crc32() {
  crc32_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Hashes::crc32() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Hashes.crc32)
  return crc32_.GetNoArena();
}
inline void Hashes::set_crc32(const ::std::string& value) {
  
  crc32_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.Hashes.crc32)
}
#if LANG_CXX11
inline void Hashes::set_crc32(::std::string&& value) {
  
  crc32_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc_services.storage.Hashes.crc32)
}
#endif
inline void Hashes::set_crc32(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  crc32_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc_services.storage.Hashes.crc32)
}
inline void Hashes::set_crc32(const char* value, size_t size) {
  
  crc32_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc_services.storage.Hashes.crc32)
}
inline ::std::string* Hashes::mutable_crc32() {
  
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Hashes.crc32)
  return crc32_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Hashes::release_crc32() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Hashes.crc32)
  
  return crc32_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hashes::set_allocated_crc32(::std::string* crc32) {
  if (crc32 != NULL) {
    
  } else {
    
  }
  crc32_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), crc32);
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Hashes.crc32)
}

// string sha1 = 2;
inline void Hashes::clear_sha1() {
  sha1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Hashes::sha1() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Hashes.sha1)
  return sha1_.GetNoArena();
}
inline void Hashes::set_sha1(const ::std::string& value) {
  
  sha1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.Hashes.sha1)
}
#if LANG_CXX11
inline void Hashes::set_sha1(::std::string&& value) {
  
  sha1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc_services.storage.Hashes.sha1)
}
#endif
inline void Hashes::set_sha1(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sha1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc_services.storage.Hashes.sha1)
}
inline void Hashes::set_sha1(const char* value, size_t size) {
  
  sha1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc_services.storage.Hashes.sha1)
}
inline ::std::string* Hashes::mutable_sha1() {
  
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Hashes.sha1)
  return sha1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Hashes::release_sha1() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Hashes.sha1)
  
  return sha1_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hashes::set_allocated_sha1(::std::string* sha1) {
  if (sha1 != NULL) {
    
  } else {
    
  }
  sha1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha1);
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Hashes.sha1)
}

// string md5 = 3;
inline void Hashes::clear_md5() {
  md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Hashes::md5() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Hashes.md5)
  return md5_.GetNoArena();
}
inline void Hashes::set_md5(const ::std::string& value) {
  
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.Hashes.md5)
}
#if LANG_CXX11
inline void Hashes::set_md5(::std::string&& value) {
  
  md5_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc_services.storage.Hashes.md5)
}
#endif
inline void Hashes::set_md5(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc_services.storage.Hashes.md5)
}
inline void Hashes::set_md5(const char* value, size_t size) {
  
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc_services.storage.Hashes.md5)
}
inline ::std::string* Hashes::mutable_md5() {
  
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Hashes.md5)
  return md5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Hashes::release_md5() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Hashes.md5)
  
  return md5_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hashes::set_allocated_md5(::std::string* md5) {
  if (md5 != NULL) {
    
  } else {
    
  }
  md5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Hashes.md5)
}

// string sha512 = 4;
inline void Hashes::clear_sha512() {
  sha512_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Hashes::sha512() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Hashes.sha512)
  return sha512_.GetNoArena();
}
inline void Hashes::set_sha512(const ::std::string& value) {
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.Hashes.sha512)
}
#if LANG_CXX11
inline void Hashes::set_sha512(::std::string&& value) {
  
  sha512_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc_services.storage.Hashes.sha512)
}
#endif
inline void Hashes::set_sha512(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc_services.storage.Hashes.sha512)
}
inline void Hashes::set_sha512(const char* value, size_t size) {
  
  sha512_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc_services.storage.Hashes.sha512)
}
inline ::std::string* Hashes::mutable_sha512() {
  
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Hashes.sha512)
  return sha512_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Hashes::release_sha512() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Hashes.sha512)
  
  return sha512_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hashes::set_allocated_sha512(::std::string* sha512) {
  if (sha512 != NULL) {
    
  } else {
    
  }
  sha512_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha512);
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Hashes.sha512)
}

// -------------------------------------------------------------------

// FolderFacet

// uint64 num_items = 1;
inline void FolderFacet::clear_num_items() {
  num_items_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 FolderFacet::num_items() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.FolderFacet.num_items)
  return num_items_;
}
inline void FolderFacet::set_num_items(::google::protobuf::uint64 value) {
  
  num_items_ = value;
  // @@protoc_insertion_point(field_set:grpc_services.storage.FolderFacet.num_items)
}

// -------------------------------------------------------------------

// FileFacet

// .grpc_services.storage.Hashes hashes = 1;
inline bool FileFacet::has_hashes() const {
  return this != internal_default_instance() && hashes_ != NULL;
}
inline void FileFacet::clear_hashes() {
  if (GetArenaNoVirtual() == NULL && hashes_ != NULL) {
    delete hashes_;
  }
  hashes_ = NULL;
}
inline const ::grpc_services::storage::Hashes& FileFacet::hashes() const {
  const ::grpc_services::storage::Hashes* p = hashes_;
  // @@protoc_insertion_point(field_get:grpc_services.storage.FileFacet.hashes)
  return p != NULL ? *p : *reinterpret_cast<const ::grpc_services::storage::Hashes*>(
      &::grpc_services::storage::_Hashes_default_instance_);
}
inline ::grpc_services::storage::Hashes* FileFacet::release_hashes() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.FileFacet.hashes)
  
  ::grpc_services::storage::Hashes* temp = hashes_;
  hashes_ = NULL;
  return temp;
}
inline ::grpc_services::storage::Hashes* FileFacet::mutable_hashes() {
  
  if (hashes_ == NULL) {
    hashes_ = new ::grpc_services::storage::Hashes;
  }
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.FileFacet.hashes)
  return hashes_;
}
inline void FileFacet::set_allocated_hashes(::grpc_services::storage::Hashes* hashes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete hashes_;
  }
  if (hashes) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hashes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hashes, submessage_arena);
    }
    
  } else {
    
  }
  hashes_ = hashes;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.FileFacet.hashes)
}

// string mime_type = 2;
inline void FileFacet::clear_mime_type() {
  mime_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FileFacet::mime_type() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.FileFacet.mime_type)
  return mime_type_.GetNoArena();
}
inline void FileFacet::set_mime_type(const ::std::string& value) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.FileFacet.mime_type)
}
#if LANG_CXX11
inline void FileFacet::set_mime_type(::std::string&& value) {
  
  mime_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc_services.storage.FileFacet.mime_type)
}
#endif
inline void FileFacet::set_mime_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc_services.storage.FileFacet.mime_type)
}
inline void FileFacet::set_mime_type(const char* value, size_t size) {
  
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc_services.storage.FileFacet.mime_type)
}
inline ::std::string* FileFacet::mutable_mime_type() {
  
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.FileFacet.mime_type)
  return mime_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileFacet::release_mime_type() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.FileFacet.mime_type)
  
  return mime_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileFacet::set_allocated_mime_type(::std::string* mime_type) {
  if (mime_type != NULL) {
    
  } else {
    
  }
  mime_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mime_type);
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.FileFacet.mime_type)
}

// .grpc_services.storage.AudioFacet audio = 3;
inline bool FileFacet::has_audio() const {
  return this != internal_default_instance() && audio_ != NULL;
}
inline void FileFacet::clear_audio() {
  if (GetArenaNoVirtual() == NULL && audio_ != NULL) {
    delete audio_;
  }
  audio_ = NULL;
}
inline const ::grpc_services::storage::AudioFacet& FileFacet::audio() const {
  const ::grpc_services::storage::AudioFacet* p = audio_;
  // @@protoc_insertion_point(field_get:grpc_services.storage.FileFacet.audio)
  return p != NULL ? *p : *reinterpret_cast<const ::grpc_services::storage::AudioFacet*>(
      &::grpc_services::storage::_AudioFacet_default_instance_);
}
inline ::grpc_services::storage::AudioFacet* FileFacet::release_audio() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.FileFacet.audio)
  
  ::grpc_services::storage::AudioFacet* temp = audio_;
  audio_ = NULL;
  return temp;
}
inline ::grpc_services::storage::AudioFacet* FileFacet::mutable_audio() {
  
  if (audio_ == NULL) {
    audio_ = new ::grpc_services::storage::AudioFacet;
  }
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.FileFacet.audio)
  return audio_;
}
inline void FileFacet::set_allocated_audio(::grpc_services::storage::AudioFacet* audio) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete audio_;
  }
  if (audio) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      audio = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.FileFacet.audio)
}

// -------------------------------------------------------------------

// AudioFacet

// uint64 bitrate = 1;
inline void AudioFacet::clear_bitrate() {
  bitrate_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AudioFacet::bitrate() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.AudioFacet.bitrate)
  return bitrate_;
}
inline void AudioFacet::set_bitrate(::google::protobuf::uint64 value) {
  
  bitrate_ = value;
  // @@protoc_insertion_point(field_set:grpc_services.storage.AudioFacet.bitrate)
}

// uint64 duration = 2;
inline void AudioFacet::clear_duration() {
  duration_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AudioFacet::duration() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.AudioFacet.duration)
  return duration_;
}
inline void AudioFacet::set_duration(::google::protobuf::uint64 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:grpc_services.storage.AudioFacet.duration)
}

// bool is_vbr = 3;
inline void AudioFacet::clear_is_vbr() {
  is_vbr_ = false;
}
inline bool AudioFacet::is_vbr() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.AudioFacet.is_vbr)
  return is_vbr_;
}
inline void AudioFacet::set_is_vbr(bool value) {
  
  is_vbr_ = value;
  // @@protoc_insertion_point(field_set:grpc_services.storage.AudioFacet.is_vbr)
}

// -------------------------------------------------------------------

// Drive

// string id = 1;
inline void Drive::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Drive::id() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Drive.id)
  return id_.GetNoArena();
}
inline void Drive::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.Drive.id)
}
#if LANG_CXX11
inline void Drive::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc_services.storage.Drive.id)
}
#endif
inline void Drive::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc_services.storage.Drive.id)
}
inline void Drive::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc_services.storage.Drive.id)
}
inline ::std::string* Drive::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Drive.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Drive::release_id() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Drive.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Drive::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Drive.id)
}

// string name = 2;
inline void Drive::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Drive::name() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Drive.name)
  return name_.GetNoArena();
}
inline void Drive::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.Drive.name)
}
#if LANG_CXX11
inline void Drive::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc_services.storage.Drive.name)
}
#endif
inline void Drive::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc_services.storage.Drive.name)
}
inline void Drive::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc_services.storage.Drive.name)
}
inline ::std::string* Drive::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Drive.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Drive::release_name() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Drive.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Drive::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Drive.name)
}

// string description = 3;
inline void Drive::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Drive::description() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Drive.description)
  return description_.GetNoArena();
}
inline void Drive::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.Drive.description)
}
#if LANG_CXX11
inline void Drive::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc_services.storage.Drive.description)
}
#endif
inline void Drive::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc_services.storage.Drive.description)
}
inline void Drive::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc_services.storage.Drive.description)
}
inline ::std::string* Drive::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Drive.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Drive::release_description() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Drive.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Drive::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Drive.description)
}

// .grpc_services.common.Timestamp created_time = 4;
inline bool Drive::has_created_time() const {
  return this != internal_default_instance() && created_time_ != NULL;
}
inline const ::grpc_services::common::Timestamp& Drive::created_time() const {
  const ::grpc_services::common::Timestamp* p = created_time_;
  // @@protoc_insertion_point(field_get:grpc_services.storage.Drive.created_time)
  return p != NULL ? *p : *reinterpret_cast<const ::grpc_services::common::Timestamp*>(
      &::grpc_services::common::_Timestamp_default_instance_);
}
inline ::grpc_services::common::Timestamp* Drive::release_created_time() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Drive.created_time)
  
  ::grpc_services::common::Timestamp* temp = created_time_;
  created_time_ = NULL;
  return temp;
}
inline ::grpc_services::common::Timestamp* Drive::mutable_created_time() {
  
  if (created_time_ == NULL) {
    created_time_ = new ::grpc_services::common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Drive.created_time)
  return created_time_;
}
inline void Drive::set_allocated_created_time(::grpc_services::common::Timestamp* created_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(created_time_);
  }
  if (created_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      created_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, created_time, submessage_arena);
    }
    
  } else {
    
  }
  created_time_ = created_time;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Drive.created_time)
}

// .grpc_services.common.Timestamp last_modified = 5;
inline bool Drive::has_last_modified() const {
  return this != internal_default_instance() && last_modified_ != NULL;
}
inline const ::grpc_services::common::Timestamp& Drive::last_modified() const {
  const ::grpc_services::common::Timestamp* p = last_modified_;
  // @@protoc_insertion_point(field_get:grpc_services.storage.Drive.last_modified)
  return p != NULL ? *p : *reinterpret_cast<const ::grpc_services::common::Timestamp*>(
      &::grpc_services::common::_Timestamp_default_instance_);
}
inline ::grpc_services::common::Timestamp* Drive::release_last_modified() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Drive.last_modified)
  
  ::grpc_services::common::Timestamp* temp = last_modified_;
  last_modified_ = NULL;
  return temp;
}
inline ::grpc_services::common::Timestamp* Drive::mutable_last_modified() {
  
  if (last_modified_ == NULL) {
    last_modified_ = new ::grpc_services::common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Drive.last_modified)
  return last_modified_;
}
inline void Drive::set_allocated_last_modified(::grpc_services::common::Timestamp* last_modified) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(last_modified_);
  }
  if (last_modified) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      last_modified = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, last_modified, submessage_arena);
    }
    
  } else {
    
  }
  last_modified_ = last_modified;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Drive.last_modified)
}

// .grpc_services.common.Timestamp last_item_modified = 6;
inline bool Drive::has_last_item_modified() const {
  return this != internal_default_instance() && last_item_modified_ != NULL;
}
inline const ::grpc_services::common::Timestamp& Drive::last_item_modified() const {
  const ::grpc_services::common::Timestamp* p = last_item_modified_;
  // @@protoc_insertion_point(field_get:grpc_services.storage.Drive.last_item_modified)
  return p != NULL ? *p : *reinterpret_cast<const ::grpc_services::common::Timestamp*>(
      &::grpc_services::common::_Timestamp_default_instance_);
}
inline ::grpc_services::common::Timestamp* Drive::release_last_item_modified() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Drive.last_item_modified)
  
  ::grpc_services::common::Timestamp* temp = last_item_modified_;
  last_item_modified_ = NULL;
  return temp;
}
inline ::grpc_services::common::Timestamp* Drive::mutable_last_item_modified() {
  
  if (last_item_modified_ == NULL) {
    last_item_modified_ = new ::grpc_services::common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Drive.last_item_modified)
  return last_item_modified_;
}
inline void Drive::set_allocated_last_item_modified(::grpc_services::common::Timestamp* last_item_modified) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(last_item_modified_);
  }
  if (last_item_modified) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      last_item_modified = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, last_item_modified, submessage_arena);
    }
    
  } else {
    
  }
  last_item_modified_ = last_item_modified;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Drive.last_item_modified)
}

// -------------------------------------------------------------------

// Item

// string id = 1;
inline void Item::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Item::id() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.id)
  return id_.GetNoArena();
}
inline void Item::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.Item.id)
}
#if LANG_CXX11
inline void Item::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc_services.storage.Item.id)
}
#endif
inline void Item::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc_services.storage.Item.id)
}
inline void Item::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc_services.storage.Item.id)
}
inline ::std::string* Item::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Item::release_id() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Item::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Item.id)
}

// string name = 2;
inline void Item::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Item::name() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.name)
  return name_.GetNoArena();
}
inline void Item::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.Item.name)
}
#if LANG_CXX11
inline void Item::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc_services.storage.Item.name)
}
#endif
inline void Item::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc_services.storage.Item.name)
}
inline void Item::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc_services.storage.Item.name)
}
inline ::std::string* Item::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Item::release_name() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Item::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Item.name)
}

// string description = 3;
inline void Item::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Item::description() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.description)
  return description_.GetNoArena();
}
inline void Item::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.Item.description)
}
#if LANG_CXX11
inline void Item::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc_services.storage.Item.description)
}
#endif
inline void Item::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc_services.storage.Item.description)
}
inline void Item::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc_services.storage.Item.description)
}
inline ::std::string* Item::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Item::release_description() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Item::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Item.description)
}

// .grpc_services.common.Timestamp created_time = 4;
inline bool Item::has_created_time() const {
  return this != internal_default_instance() && created_time_ != NULL;
}
inline const ::grpc_services::common::Timestamp& Item::created_time() const {
  const ::grpc_services::common::Timestamp* p = created_time_;
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.created_time)
  return p != NULL ? *p : *reinterpret_cast<const ::grpc_services::common::Timestamp*>(
      &::grpc_services::common::_Timestamp_default_instance_);
}
inline ::grpc_services::common::Timestamp* Item::release_created_time() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.created_time)
  
  ::grpc_services::common::Timestamp* temp = created_time_;
  created_time_ = NULL;
  return temp;
}
inline ::grpc_services::common::Timestamp* Item::mutable_created_time() {
  
  if (created_time_ == NULL) {
    created_time_ = new ::grpc_services::common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.created_time)
  return created_time_;
}
inline void Item::set_allocated_created_time(::grpc_services::common::Timestamp* created_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(created_time_);
  }
  if (created_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      created_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, created_time, submessage_arena);
    }
    
  } else {
    
  }
  created_time_ = created_time;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Item.created_time)
}

// .grpc_services.common.Timestamp last_modified = 5;
inline bool Item::has_last_modified() const {
  return this != internal_default_instance() && last_modified_ != NULL;
}
inline const ::grpc_services::common::Timestamp& Item::last_modified() const {
  const ::grpc_services::common::Timestamp* p = last_modified_;
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.last_modified)
  return p != NULL ? *p : *reinterpret_cast<const ::grpc_services::common::Timestamp*>(
      &::grpc_services::common::_Timestamp_default_instance_);
}
inline ::grpc_services::common::Timestamp* Item::release_last_modified() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.last_modified)
  
  ::grpc_services::common::Timestamp* temp = last_modified_;
  last_modified_ = NULL;
  return temp;
}
inline ::grpc_services::common::Timestamp* Item::mutable_last_modified() {
  
  if (last_modified_ == NULL) {
    last_modified_ = new ::grpc_services::common::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.last_modified)
  return last_modified_;
}
inline void Item::set_allocated_last_modified(::grpc_services::common::Timestamp* last_modified) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(last_modified_);
  }
  if (last_modified) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      last_modified = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, last_modified, submessage_arena);
    }
    
  } else {
    
  }
  last_modified_ = last_modified;
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Item.last_modified)
}

// string parent_id = 6;
inline void Item::clear_parent_id() {
  parent_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Item::parent_id() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.parent_id)
  return parent_id_.GetNoArena();
}
inline void Item::set_parent_id(const ::std::string& value) {
  
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:grpc_services.storage.Item.parent_id)
}
#if LANG_CXX11
inline void Item::set_parent_id(::std::string&& value) {
  
  parent_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:grpc_services.storage.Item.parent_id)
}
#endif
inline void Item::set_parent_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:grpc_services.storage.Item.parent_id)
}
inline void Item::set_parent_id(const char* value, size_t size) {
  
  parent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:grpc_services.storage.Item.parent_id)
}
inline ::std::string* Item::mutable_parent_id() {
  
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.parent_id)
  return parent_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Item::release_parent_id() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.parent_id)
  
  return parent_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Item::set_allocated_parent_id(::std::string* parent_id) {
  if (parent_id != NULL) {
    
  } else {
    
  }
  parent_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_id);
  // @@protoc_insertion_point(field_set_allocated:grpc_services.storage.Item.parent_id)
}

// uint64 size = 7;
inline void Item::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Item::size() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.size)
  return size_;
}
inline void Item::set_size(::google::protobuf::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:grpc_services.storage.Item.size)
}

// .grpc_services.storage.FileFacet file = 8;
inline bool Item::has_file() const {
  return test_type_case() == kFile;
}
inline void Item::set_has_file() {
  _oneof_case_[0] = kFile;
}
inline void Item::clear_file() {
  if (has_file()) {
    delete test_type_.file_;
    clear_has_test_type();
  }
}
inline ::grpc_services::storage::FileFacet* Item::release_file() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.file)
  if (has_file()) {
    clear_has_test_type();
      ::grpc_services::storage::FileFacet* temp = test_type_.file_;
    test_type_.file_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::grpc_services::storage::FileFacet& Item::file() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.file)
  return has_file()
      ? *test_type_.file_
      : *reinterpret_cast< ::grpc_services::storage::FileFacet*>(&::grpc_services::storage::_FileFacet_default_instance_);
}
inline ::grpc_services::storage::FileFacet* Item::mutable_file() {
  if (!has_file()) {
    clear_test_type();
    set_has_file();
    test_type_.file_ = new ::grpc_services::storage::FileFacet;
  }
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.file)
  return test_type_.file_;
}

// .grpc_services.storage.FolderFacet folder = 9;
inline bool Item::has_folder() const {
  return test_type_case() == kFolder;
}
inline void Item::set_has_folder() {
  _oneof_case_[0] = kFolder;
}
inline void Item::clear_folder() {
  if (has_folder()) {
    delete test_type_.folder_;
    clear_has_test_type();
  }
}
inline ::grpc_services::storage::FolderFacet* Item::release_folder() {
  // @@protoc_insertion_point(field_release:grpc_services.storage.Item.folder)
  if (has_folder()) {
    clear_has_test_type();
      ::grpc_services::storage::FolderFacet* temp = test_type_.folder_;
    test_type_.folder_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::grpc_services::storage::FolderFacet& Item::folder() const {
  // @@protoc_insertion_point(field_get:grpc_services.storage.Item.folder)
  return has_folder()
      ? *test_type_.folder_
      : *reinterpret_cast< ::grpc_services::storage::FolderFacet*>(&::grpc_services::storage::_FolderFacet_default_instance_);
}
inline ::grpc_services::storage::FolderFacet* Item::mutable_folder() {
  if (!has_folder()) {
    clear_test_type();
    set_has_folder();
    test_type_.folder_ = new ::grpc_services::storage::FolderFacet;
  }
  // @@protoc_insertion_point(field_mutable:grpc_services.storage.Item.folder)
  return test_type_.folder_;
}

inline bool Item::has_test_type() const {
  return test_type_case() != TEST_TYPE_NOT_SET;
}
inline void Item::clear_has_test_type() {
  _oneof_case_[0] = TEST_TYPE_NOT_SET;
}
inline Item::TestTypeCase Item::test_type_case() const {
  return Item::TestTypeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace storage
}  // namespace grpc_services

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_storage_2fentities_2eproto__INCLUDED
